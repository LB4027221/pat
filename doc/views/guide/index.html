<h1 id="pat">pat</h1>
<p><img src="https://img.alicdn.com/tps/TB1c.FiLVXXXXXpapXXXXXXXXXX-128-128.png" alt="pat"></p>
<button class="btn">222</button>

<script type="text/javascript">


  var a = 111;
</script>

<p>pat是一个轻量级的指令型模板解决方案。具备局部刷新，双向绑定，指令扩展，filter过滤等功能。</p>
<p>如果你用过angular或者vue,应该对指令（directive）这个概念不会陌生,angular大而全，vue精简了一部分留下了组件，而pat在angular，react，vue的基础上，结合各自的特点专注于解决模板层面的问题。</p>
<p>与目前主要的框架相比，pat具有以下特点：</p>
<ul>
<li>单一职责，pat只负责解决模板问题。使用者可以单独使用，也可以跟任何其他框架结合使用。</li>
<li>支持mustache风格的模板语法，避免了指令写多了模板可读性差的问题。</li>
<li>具有指令型框架的特点，扩展性强，功能强大，可以扩展自己的指令。同时支持filter与自定义watcher。</li>
<li>具有virtual dom中间层，一方面加快了分析指令的速度，另一方面也为服务端渲染提供了可能。</li>
<li>考虑到目前国内情况，pat做了大量事情，兼容到了ie8。</li>
<li>同时支持脏检测与defineproperty的数据检测机制。在defineproperty模式下使用vbscript来做ie8兼容处理。</li>
</ul>
<p>详细文档请点这里：<a href="http://www.baidu.com">http://www.baidu.com</a></p>
<h2 id="usage">usage</h2>
<p>直接使用线上地址：</p>
<p>压缩版本：</p>
<pre><code>http://g.alicdn.com/mm/pat/1.0/pat-min.js
</code></pre><p>未压缩版本：</p>
<pre><code>http://g.alicdn.com/mm/pat/1.0/pat.js
</code></pre><h2 id="getting-stared">Getting Stared</h2>
<h3 id="hello-world">hello world</h3>
<p>我们来看下最简单的例子：</p>
<pre><code class="lang-js">
html:
&lt;div id=&quot;test&quot;&gt;{{text}}&lt;/div&gt;

js:
var p = new Pat({
  el:&#39;test&#39;,
  data:{
    text:&#39;hello world&#39;
  }
})
</code></pre>
<p>展现出来就是hello world，这是最简单的渲染。这边的<code>{{}}</code>称之为插值。默认会转义，如果不想要转义，就像mustache那样使用<code>{{{}}}</code>来实现。</p>
<blockquote>
<p>如react那样，pat会针对每个dom元素加上一个标识id，用于后面局部刷新时去找dom节点。如果是插值渲染的文本节点那么会跟react那样包裹一个span标记。而对于普通文本不会包裹。</p>
</blockquote>
<h3 id="-">列表</h3>
<p>下面是一个列表渲染的例子，支持mustache风格的语法，我们更推荐使用mustache风格的语法，可读性更好。</p>
<pre><code class="lang-js">
html:

&lt;!--指令型语法--&gt;
&lt;!--
&lt;div t-if=&quot;item in lists&quot; id=&quot;test&quot;&gt;{{item.name}}-{{__INDEX__}}&lt;/div&gt;
--&gt;

&lt;!--mustache风格语法--&gt;
{{#for(item in lists)}}
&lt;div id=&quot;test&quot;&gt;{{item.name}}-{{__INDEX__}}&lt;/div&gt;
{{/for}}

js:
var p = new Pat({
  el:&#39;test&#39;,
  data:{
    lists:[{
        name:&#39;1111&#39;
    },{
        name:&#39;2222&#39;
    }],
    text:&#39;hello world&#39;
  }
})
</code></pre>
<p>for指令可以使用<code>__INDEX__</code>拿到当前的index。</p>
<blockquote>
<p>pat的指令都有一个<code>t</code>的前缀，对于 for，if，unless都是一种指令。实际上就连上面的插值也是一种特殊的指令，指令是pat的核心技术。用户也可以扩展自己的指令。</p>
</blockquote>
<h3 id="-">局部刷新</h3>
<p>pat使局部刷新更加简单，通过操作数据来达到dom的局部更新目的。</p>
<pre><code class="lang-js">
html:
&lt;div id=&quot;test&quot;&gt;{{text}}&lt;/div&gt;

js:
var p = new Pat({
  el:&#39;test&#39;,
  data:{
    text:&#39;hello world&#39;
  }
})

p.$data.text = &quot;hi world&quot;
</code></pre>
<p>每一个pat实例都会有一个$data属性，它是pat托管的数据，可以通过修改$data里面的值来达到局部刷新的目的。避免了复杂的dom操作。</p>
<blockquote>
<p>pat同时支持两种数据变化监听机制，默认使用defineproperty机制，使用注入get set的方式监听数据变更之后批量修改。另外也支持脏检测机制，兼容性以及开发体验更好。详情<a href="">点此了解</a>。</p>
</blockquote>
<h3 id="-">双向绑定</h3>
<p>与angular，vue一样，用户可以使用<code>t-model</code>指令来选择性的使用双向绑定的功能。</p>
<pre><code class="lang-js">
html:
&lt;div id=&quot;test&quot;&gt;{{text}}&lt;/div&gt;
&lt;input type=&quot;text&quot; value=&quot;&quot; t-model=&quot;text&quot;&gt;

js:
var p = new Pat({
  el:&#39;test&#39;,
  data:{
    text:&#39;hello world&#39;
  }
})
</code></pre>
<p>更多详细用法，<a href="">请点这里</a>。</p>
<h2 id="test">test</h2>
<p>采用karma + jasmine做功能性测试，后期考虑使用nightwatch或者casper来做ui的e2e测试</p>
<pre><code>npm test
</code></pre><h2 id="build">build</h2>
<p>项目使用webpack打包，在根目录执行：</p>
<pre><code>npm run-script build
</code></pre>